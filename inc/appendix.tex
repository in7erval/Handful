Код реализации алгоритма и построения изображений:

\begin{minted}[mathescape, 
				linenos,
				gobble=0, 
				frame=lines,
				framesep=2mm]{python}
import numpy as np
import cv2
import matplotlib.pyplot as plt


def get_min_max(image_flatten: np.ndarray) -> tuple:
    min_pix, max_pix = image_flatten[0], image_flatten[0]
    for pixel in image_flatten:
        if pixel < min_pix:
            min_pix = pixel
        if pixel > max_pix:
            max_pix = pixel
    return min_pix, max_pix


def create_histogram(image_flatten: np.ndarray, 
					size: int, min_pix: int) -> np.array:
    hist = np.zeros(size)
    for pixel in image_flatten:
        hist[pixel - min_pix] += 1
    return hist


def otsu_threshold(image: np.ndarray):
    img_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    img_gray_flatten = img_gray.flatten()
    min_pixel, max_pixel = get_min_max(img_gray_flatten)
    size = max_pixel - min_pixel + 1
    histogram = create_histogram(img_gray_flatten, size, min_pixel)
    m = 0
    n = 0
    for i in range(size):
        m += i * histogram[i]
        n += histogram[i]
    max_sigma = -1
    threshold = 0
    alpha1 = 0
    beta1 = 0
    for i in range(size - 1):
        alpha1 += i * histogram[i]
        beta1 += histogram[i]
        w1 = float(beta1) / n  # Вероятность класса 1
        w2 = 1 - w1
        a = float(alpha1) / beta1 - float(m - alpha1) / (n - beta1) 
        sigma = w1 * w2 * a * a
        if sigma > max_sigma:
            max_sigma = sigma
            threshold = i
    threshold += min_pixel
    return threshold


def save_histogram(image, fname: str):
    image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY).flatten()
    plt.hist(image, 255)
    plt.xlim([0, 255])
    plt.savefig(fname)
    plt.show()


INPUT_TO_OUTPUT = {'image3.jpg':
                       {'histogram': 'histogram_for_3.png',
                        'output': 'otsu_exmpl_for_3.png'},
                   'image7.jpg':
                       {'histogram': 'histogram_for_7.png',
                        'output': 'otsu_exmpl_for_7.png'}
                   }

if __name__ == '__main__':
    for fname, outputs in INPUT_TO_OUTPUT.items():
        image = cv2.imread(fname)
        save_histogram(image, outputs['histogram'])
        thresh = otsu_threshold(image)
        print(f'Threshold = {thresh}')
        ret, img_thresh = cv2.threshold(cv2.cvtColor(image, cv2.COLOR_BGR2GRAY), thresh, 255, cv2.THRESH_BINARY)
        imask = img_thresh == 255
        canvas = np.zeros_like(image, np.uint8)
        canvas[imask] = image[imask]
        cv2.imwrite(outputs['output'], canvas)
\end{minted}

\newpage

Код реализации алгоритма Грэхема:

\begin{minted}[mathescape, 
				linenos,
				gobble=0, 
				frame=lines,
				framesep=2mm]{python}
from functools import cmp_to_key

class Point:
    def __init__(self, x=None, y=None):
        self.x = x
        self.y = y

# Расстояние между двумя точками
def dist_sq(p1, p2):
    return ((p1.x - p2.x) * (p1.x - p2.x) +
            (p1.y - p2.y) * (p1.y - p2.y))

# Определение ориентации трёх точек
# (перекрестное произведение векторов pq и qr)
def orientation(p, q, r):
    val = ((q.y - p.y) * (r.x - q.x) -
           (q.x - p.x) * (r.y - q.y))
    if val == 0:
        return 0  # коллинеарны
    elif val > 0:
        return 1  # по часовой
    else:
        return 2  # против часовой

# Сравнение двух точек для сортировки
def compare(p1, p2):
    global p0
    o = orientation(p0, p1, p2)
    if o == 0:
        return -1 if dist_sq(p0, p2) >= dist_sq(p0, p1) else 1
    else:
        return -1 if o == 2 else 1

def convex_hull(input_points: list) -> list:
    # Конвертируем в класс Point
    points = [Point(point[0], point[1]) for point in input_points]
    n = len(input_points)
    # Находим минимальную точку
    min_y = points[0].y
    min_i = 0
    for i in range(1, n):
        y = points[i].y
        if ((y < min_y) or
                (min_y == y and points[i].x < points[min_i].x)):
            min_y = points[i].y
            min_i = i

    points[0], points[min_i] = points[min_i], points[0]

    # Сортируем массив
    global p0
    p0 = points[0]
    points = sorted(points, key=cmp_to_key(compare))

    m = 1  # Начальный размер нового массива
    # Удаляем лишние точки
    for i in range(1, n):
        while ((i < n - 1) and
               (orientation(p0, points[i], points[i + 1]) == 0)):
            i += 1
        points[m] = points[i]
        m += 1
    if m < 3:
        return None

    S = [points[0], points[1], points[2]]
    for i in range(3, m):
        while ((len(S) > 1) and
               (orientation(S[-2], S[-1], points[i]) != 2)):
            S.pop()
        S.append(points[i])

    return [(p.x, p.y) for p in S]
\end{minted}

