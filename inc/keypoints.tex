\section{Методы нахождения ключевых точек на кисти.}

Особую сложность представляет задача 
определения положения ключевых точек на кисти человека.
Для этой нетривиальной задачи было предложено
несколько методов её решения. Рассмотрим каждый из них.

\subsection{Нахождение точек путём определения дефектов 
выпуклости.}

В предыдущем разделе был рассмотрен метод построения контура
кисти с помощью топологического структурного анализа
цифрового бинарного изображения с помощью отслеживания
границ. Этот метод хорош тем, что позволяет позволяет
определить точные координаты точек контура. С помощью этих
точек существует возможность построить {\it выпуклую
оболочку} или их {\it наименьшее множество}.

Выпуклой оболочкой множества $X$ называется наименьшее
выпуклое множество, содержащее $X$. 
«Наименьшее множество» здесь означает наименьший элемент по
отношению к вложению множеств, то есть такое выпуклое
множество, содержащее данную фигуру, что оно содержится в
любом другом выпуклом множестве, содержащем данную фигуру.

Рассмотрим основные алгоритмы построения выпуклой оболочки.

\subsubsection{Алгоритм Грэхема.}

Алгоритм Грэхема\cite{graham} — алгоритм построения выпуклой
оболочки в двумерном пространстве. В этом алгоритме задача о
выпуклой оболочке решается с помощью стека, сформированного
из точек-кандидатов. Все точки входного множества заносятся в
стек, а потом точки, не являющиеся вершинами выпуклой
оболочки, со временем удаляются из него. По завершении работы
алгоритма в стеке остаются только вершины оболочки в порядке
их обхода против часовой стрелки.

Временная сложность алгоритма = O($n\log{n}$).

{\bf Описание алгоритма:}

Пусть точки $p=[p_0,...p_{n-1}]$ -- входной массив точек.
\begin{enumerate}
	\item Найти самую "нижнюю"\ точку в массиве (ту, в которой
наименьшая среди всех координата $y$). Если таких точек несколько, то
среди них выбрать точку с наименьшей координатой $x$. Найденная точка
$P_0$ является первой точкой выпуклой оболочки;
	\item Перебрать остальные $n-1$ точек и отсортировать их по 
полярному углу относительно $P_0$ в направлении против часовой стрелки.
Если полярный угол нескольких точек одинаков, то выбрать ближайшую к 
$P_0$;
	\item После сортировки, проверить, есть ли точки с одинаковым 
полярным углом. Если да, то удалить все эти точки, кроме ближайшей к
$P_0$. Положить размер нового массива равным $m$;
	\item Если $m < 3$, то алгоритм прерывается. Выпуклую оболочку 
определить невозможно;
	\item Создать пустой стек $S$ и положить в него первые три точки 
нового массива $p_0, p_1, p_2$;
	\item Для каждой из оставшихся $m-3$ точек:
	\begin{enumerate}
		\item Удаляем точки из стека пока ориентация трёх следующих
точек не против часовой стрелки (они не совершают левый поворот):
точка наверху стека, точка следующая после неё и текущая точка $p_i$;
		\item Добавляем точку $p_i$ в $S$;
	\end{enumerate}
	\item Стек S содержит точки выпуклой оболочки.
\end{enumerate}

Реализация алгоритма Грэхема на языке Python находится в приложении.
С помощью следующего кода протестируем алгоритм на случайном наборе
точек. Результат работы показан на рисунке \ref{graham-ex}.
 
\begin{minted}[mathescape, 
				linenos,
				gobble=0, 
				frame=lines,
				framesep=2mm]{python}
import numpy as np
import random
from matplotlib import pyplot as plt
import cv2

from my_convex_hulls.convexHullGraham import convex_hull \
    as convex_hull_graham

def get_random_point(height, width) -> tuple:
    return random.randint(width // 3, width), \
           random.randint(height // 3, height)

def plot_images(img1, img2):
    fig, axes = plt.subplots(1, 2)
    fig.set_figwidth(10)
    fig.set_figheight(5)
    axes = axes.flatten()
    axes[0].imshow(img1)
    axes[1].imshow(img2)
    for ax in axes:
        ax.set_xticks([])
        ax.set_yticks([])
    plt.show()
    fig.savefig(f'graham_test.png')

def draw_convex_hull(img_init, points):
    img = img_init.copy()
    for i in range(len(points) - 1):
        cv2.line(img, points[i],
                 points[i + 1], (0, 255, 0), 2)
    cv2.line(img, points[0],
             points[-1], (0, 255, 0), 2)
    return img

if __name__ == '__main__':
    width, height = 500, 500
    num_points = 20
    img = np.zeros((width, height, 3))
    points = [get_random_point(width * 4 // 5, height * 4 // 5)
              for _ in range(num_points)]
    for point in points:
        cv2.circle(img, point, 5, (255, 0, 0), -1)
    convex_hull_points = convex_hull_graham(points)
    img_copy = draw_convex_hull(img, convex_hull_points)
    plot_images(img, img_copy)
\end{minted}

\addimghere{pix/graham_test}{0.9}{Сгенерированные точки (слева) и их 
выпуклая оболочка, найденная с помощью алгоритма Грэхема (справа).}
{graham-ex}

\subsubsection{Алгоритм Джарвиса.}

Алгоритм Джарвиса \cite{jarvis} (или алгоритм обхода Джарвиса, или алгоритм
заворачивания подарка) определяет последовательность элементов
множества, образующих выпуклую оболочку для этого множества. Метод
можно представить как обтягивание верёвкой множества вбитых в доску
гвоздей. Алгоритм работает за время  O($nh$), где $n$ -- общее число 
точек на плоскости, а $h$ -- число точек в выпуклой оболочке. В 
худшем случае -- O($n^2$), когда все точки попадают в выпуклую
оболочку.

{\bf Описание алгоритма:}

Пусть дано множество точек $P = \{p_1, p_2, \ldots, p_n\}$. В качестве
начальной берётся самая левая нижняя точка $p_1$ (её можно найти за
$O(n)$ обычным проходом по всем точкам), она точно является вершиной
выпуклой оболочки. Следующей точкой ($p_2$) берём такую точку, 
которая имеет наименьший положительный полярный угол относительно точки
$p_1$ как начала координат. После этого для каждой точки $p_i$ 
($2 < i \leq |P|$) против часовой стрелки ищется такая точка $p_{i+1}$,
путём нахождения за $O(n)$ среди оставшихся точек 
(+ самая левая нижняя),
в которой будет образовываться наибольший угол между прямыми 
$p_{i-1}p_i$ и $p_ip_{i+1}$. Она и будет следующей вершиной выпуклой
оболочки. Сам угол при этом не ищется, а ищется только его косинус 
через скалярное произведение между лучами $p_{i-1}p_i$ и 
$p_ip'_{i+1}$, где $p_i$ -- последний найденный минимум, $p_{i-1}$ -- 
предыдущий минимум, а $p'_{i+1}$ -- претендент на следующий минимум.
Новым минимумом будет та точка, в которой косинус будет принимать
наименьшее значение (чем меньше косинус, тем больше его угол).
Нахождение вершин выпуклой оболочки продолжается до тех пор, пока 
$p_{i+1} \neq p_1$. В тот момент, когда следующая точка в выпуклой
оболочке совпала с первой, алгоритм останавливается — выпуклая оболочка
построена (рис. \ref{jarvis-simple-ex}).

\addimghere{pix/jarvis-match}{1}{Пример работы алгоритма Джарвиса.}
{jarvis-simple-ex}

Реализация алгоритма Джарвиса на языке Python находится в приложении.
С помощью того же кода, но с заменой функции {\tt convex\_hull},
протестируем алгоритм на случайном наборе точек. Результат работы
показан на рисунке \ref{jarvis-ex}.

\addimghere{pix/jarvis_test}{1}{Сгенерированные точки (слева) и их 
выпуклая оболочка, найденная с помощью алгоритма Джарвиса (справа).}
{jarvis-ex}

Можно видеть, что алгоритм отработал верно, но у него есть один 
существенный недостаток -- он намного медленнее по сравнению с 
алгоритмом Грэхема.

\subsubsection{Алгоритм Киркпатрика.}

Алгоритм Киркпатрика \cite{kirkpatrick} заключается в построении
выпуклой оболочки методом "разделяй и властвуй".

{\bf Описание алгоритма:}

Дано множество $S$, состоящее из $N$ точек. 
\begin{enumerate}
	\item Если $N \leq N_0$ ($N_0$ -- некоторое небольшое целое число),
то построить выпуклую оболочку одним из известных методов и
остановиться, иначе перейти к шагу 2.
	\item Разобьём исходное множество $S$ произвольным образом на два 
примерно равных по мощности подмножества $S_1$ и $S_2$ (пусть $S_1$
содержит $N/2$ точек, а $S_2$ содержит $N-N/2$ точек).
	\item Рекурсивно находим выпуклые оболочки каждого из подмножеств
$S_1$ и $S_2$.
	\item Строим выпуклую оболочку исходного множества как выпуклую 
оболочку объединения двух выпуклых многоугольников $CH(S_1)$ и
$CH(S_2)$.
\end{enumerate}
Поскольку $CH(S)=CH(S_1 \cup S_2) = CH(CH(S_1)\cup CH(S_2))$,
сложность этого алгоритма является решением рекурсивного соотношения
$T(N)\leq 2T(N/2)+f(N)$, где $f(N)$ -- время построения выпуклой
оболочки объединения двух выпуклых многоугольников, каждый из которых
имеет около $N/2$ вершин. Таким образом, временная сложность
этого алгоритма равна O($N\log{N}$).

Реализация алгоритма Киркпатрика на языке Python находится в
приложении. Результат работы показан на рисунке \ref{kirkpatrick-ex}.

\addimghere{pix/kirkpatrick_test}{1}{Сгенерированные точки (слева) и их 
выпуклая оболочка, найденная с помощью алгоритма Киркпатрика (справа).}
{kirkpatrick-ex}

\subsubsection{Сравнение алгоритмов.}

Для того чтобы выбрать наиболее быстрый алгоритм, проведём их сравнение
по времени работы на 1000 тестах с помощью следующего кода:

\begin{minted}[mathescape, 
				linenos,
				gobble=0, 
				frame=lines,
				framesep=2mm]{python}
#  imports
def generate_random_points(width, height, size=0, is_random=False):
    if is_random or size == 0:
        size = random.randint(100, 500)
    return [get_random_point(width * 4 // 5, height * 4 // 5) 
    	for _ in range(size)]

def get_random_point(height, width) -> tuple:
    return random.randint(width // 3, width), \
           random.randint(height // 3, height)

def measure_time(method: function, args) -> int:
    time_start = time.time_ns()
    method(args)
    return time.time_ns() - time_start

GRAHAM, JARVIS, KPATRICK = 'GRAHAM', 'JARVIS', 'KIRKPATRICK'
NAME_TO_ALGO = {GRAHAM: convex_hull_graham, 
	JARVIS: convex_hull_jarvis, 
	KPATRICK: convex_hull_kirkpatrick}
width, height, num_tests = 5000, 5000, 1000
TIMES = {GRAHAM: [], JARVIS: [], KPATRICK: []}
for _ in range(num_tests):
    points = generate_random_points(width, height, is_random=True)
    for algo in TIMES.keys():
        TIMES[algo].append(measure_time(NAME_TO_ALGO[algo], points))
for algo, times in TIMES.items():
    print(f'-- {algo} --')
    print(f'<Max>: {max(times) // 1000} ms')
    print(f'<Min>: {min(times) // 1000} ms')
    print(f'<Mean>: {np.array(times).mean() // 1000} ms')
\end{minted}

Результаты работы сведены в таблицу \ref{table-compare-hull}.

\begin{table}[h]
\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline Алгоритм & Максимальное время, мс &
Минимальное время, мс & Среднее время, мс\\
\hline  Грэхема &  5317 & 581 & 2193.0 \\
\hline  Джарвиса & 187204 & 5979 & 66401.0 \\
\hline  Киркпатрика & 23102 & 2008  & 6944.0 \\
\hline
\end{tabular}
\end{center}
\caption{\label{table-compare-hull} Сравнение алгоритмов построения
выпуклой оболочки.}
\end{table}

Можно видеть, что самым эффективным в данном случае оказался алгоритм
Грэхема, именно его и будем использовать.

Алгоритм Грэхема уже реализован в библиотеке OpenCV в виде функции
{\tt convexHull()}. Рассмотрим её подробнее.

\subsubsection{Обзор функции {\tt convexHull()}}

Сигнатура функции {\tt convexHull()}, реализованной в библиотеке OpenCV 
для языка Python выглядит следующим образом:
\begin{minted}[mathescape, 
				linenos,
				gobble=0, 
				frame=lines,
				framesep=2mm]{python}
def convexHull(points, hull=None, clockwise=None, returnPoints=None):
	pass
\end{minted}

Параметры:
\begin{itemize}
	\item {\tt points} -- Входные точки;
	\item {\tt hull} -- Выходной массив с точками выпуклой оболочки;
	\item {\tt clockwise} -- Флаг ориентации. Если равен {\tt True},
то точки {\tt hull} ориентированы по часовой стрелке;
	\item {\tt returnPoints} -- Если равен {\tt True}, то возвращает 
точки выпуклой оболочки, иначе -- индексы из {\tt points}.
\end{itemize}

С помощью следующего кода построим контур и выпуклую оболочку
кисти руки. Результат работы программы изображён на рисунке 
\ref{hull-example}.
\begin{minted}[mathescape, 
				linenos,
				gobble=0, 
				frame=lines,
				framesep=2mm]{python}
import cv2

img = cv2.imread('image1.jpg')
img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
blurred = cv2.GaussianBlur(img_gray, (3, 3), 3)
_, image_to_contours = cv2.threshold(blurred, 0, 255,
        cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
contours, hierarchy = cv2.findContours(image_to_contours.copy(),
	cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)
cnt = max(contours, key=lambda x: cv2.contourArea(x))
cv2.drawContours(img, [cnt], -1, (0, 255, 0), 2)
hull = cv2.convexHull(cnt)
cv2.drawContours(img, [hull], -1, (255, 0, 0), 2)
cv2.imwrite('convex_hull_example.png', img)
\end{minted}

\addimghere{pix/convex_hull_example}{0.5}{Выделение контура и
выпуклой его оболочки на кисти.}{hull-example}

Для определения необходимых ключевых точек на кисти необходимо 
найти {\it дефекты выпуклости} контура и выпуклой оболочки. 

Дефект выпуклости в данном случае -- это максимальное расстояние
между выпуклой оболочкой и контуром (рис. \ref{convex-defect-simple}).

\addimghere{pix/defects}{0.4}{Дефекты выпуклости.}
{convex-defect-simple}


В библиотеке OpenCV уже существует реализация расчётов дефектов 
выпуклости в виде функции {\tt convexityDefects()}. 

\subsubsection{Обзор функции {\tt convexityDefects()}.}

Сигнатура функции в Python выглядит следующим образом:

\begin{minted}[mathescape, 
				linenos,
				gobble=0, 
				frame=lines,
				framesep=2mm]{python}
def convexityDefects(contour, convexhull, convexityDefects=None):
	pass
\end{minted}

Параметры довольно простые:
\begin{itemize}
	\item {\tt contour} -- массив точек контура;
	\item {\tt convexhull} -- массив {\it индексов} выпуклой оболочки, 
где индексы берутся из {\tt contour};
	\item {\tt convexityDefects} -- массив дефектов выпуклости, в 
каждой строке которого находятся 4 элемента:
	\begin{itemize}
		\item индекс начала дефекта;
		\item индекс конца дефекта;
		\item самая дальная точка;
		\item расстояние до контура;
	\end{itemize}
\end{itemize}

Запустив следующий код Python, получим результат вычисления, 
представленный на рисунке \ref{defects-example-1}.

\begin{minted}[mathescape, 
				linenos,
				gobble=0, 
				frame=lines,
				framesep=2mm]{python}
import cv2

def process_image(image):
    return cv2.threshold(cv2.GaussianBlur(image, (3, 3), 3), 
           0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)[1]

img = cv2.imread('image1.jpg')
img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
image_to_contours = process_image(img_gray)
contours, hierarchy = cv2.findContours(image_to_contours.copy(),
           cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)
cnt = max(contours, key=lambda x: cv2.contourArea(x))     
cv2.drawContours(img, [cnt], -1, (0, 255, 0), 2)
hull = cv2.convexHull(cnt)
cv2.drawContours(img, [hull], -1, (255, 0, 0), 2)
hull_index = cv2.convexHull(cnt, returnPoints=False)
defects = cv2.convexityDefects(cnt, hull_index)
for defect in defects:
    cv2.circle(img, cnt[defect[0][2]][0], 5, (0, 0, 255), -1)
cv2.imwrite('defects_example.png', img)
\end{minted}

\addimghere{pix/defects_example}{0.6}{Пример вычисления точек
дефектов выпуклости (красные).}{defects-example-1}

Можно видеть, что некоторые точки очень близко находятся друг к другу.
Это связано с тем, что выпуклая оболочка касается контура 
несколько раз в почти одном и том же месте. Чтобы избавиться от
этого напишем следующую функцию очистки этих точек:

\begin{minted}[mathescape, 
				linenos,
				gobble=0, 
				frame=lines,
				framesep=2mm]{python}
import math
import numpy as np

def squeeze(array):
    array = array[0] if len(array) == 1 else array
    return [p[0] for p in array] if len(array[0]) == 1 else array

# "очистка" выпуклой оболочки до не больше 7 точек
def clear_convex_hull(hull_index, contour):
    distance_point = lambda p1, p2: \
    	math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)
    hull_index, contour = squeeze(hull_index), squeeze(contour)
    ALPHA = 10
    while True:
        boundary = len(hull_index) - 1
        clean_hull, i = [], 0
        while i < boundary:
            clean_hull.append(hull_index[i])
            while i < boundary and \
                    distance_point(contour[hull_index[i]],
                    contour[hull_index[i + 1]]) < ALPHA:
                i += 1
            i += 1
        if len(clean_hull) > 7:
            ALPHA += 1
        else:
            break
    return np.array(clean_hull[:-1]) if \
        distance_point(contour[clean_hull[0]],
        contour[clean_hull[-1]]) < ALPHA else np.array(clean_hull)
\end{minted}

Функция работает следующим образом. Берётся первая попавшаяся точка
дефекта выпуклости, затем перебираются оставшиеся, пока они попадают
в круг радиусом {\tt ALPHA} с центром в первой точке. Эти точки не
попадают в итоговый результат. Затем берётся следующая точка и т.д.
Если после прохождения всех точек их количество больше 7 (2 точки
снизу руки + максимум 5 точек-"пальцев"), то {\tt ALPHA}
инкрементируется.

Результаты работы программы поиска дефектов выпуклости с 
очисткой "ненужных" точек выпуклости можно видеть на рисунке
\ref{defects-clean-ex}.

\addtwoimghere{pix/defects_clean_example}{pix/defects_clean_example1}
{Результат очистки дефектов выпуклости (оставшиеся точки 
отмечены на рисунках желтым цветом).}{defects-clean-ex}

Для того чтобы окончательно найти все точки на руке необходимо найти
центр масс контура. 

{\it Центром масс} фигуры является арифметическое среднее всех точек
фигуры. Пусть фигура состоит из $n$ отдельных точек 
$x_1, \ldots, x_n$, тогда центр масс определяется как
$$ c = \frac{1}{n}\sum_{i=1}^n{x_i}. $$

В контексте обработки изображения и компьютерного зрения каждая фигура
состоит из пикселей и центром масс является взвешенное среднее всех
пикселей, составляющих фигуру.

Центр масс контура можно найти с помощью {момента}. Момент изображения
-- это конкретное средневзвешенное значение интенсивности пикселей
изображения. Как и во всех остальных науках, моменты характеризуют
распределение материи относительно точки или оси. Формула для
момента изображения выглядит следующим образом:
\begin{equation}
M_{ij} = \sum_x{\sum_y{x^iy^iI(x,y)}}, 
\label{moments-equat}
\end{equation}
где $I(x,y)$ -- интенсивность пикселя в точке $(x,y)$,
$x$, $y$ относятся к строке и столбцу изображения. 

Проблема формулы (\ref{moments-equat}) состоит в том, что
моменты чувствительны к позициям $x$ и $y$. Если есть необходимость
в определении моментов, независимых к месту расположения контура, то
нужно использовать формулу {\it центральных моментов}:
$$M_{pq} = \sum_x{\sum_y{(x-\bar x)^p(y-\bar y)^qI(x,y)}}, $$
где $\bar x$ и $\bar y$ -- средние значения $x$ и $y$ соответственно.

Координата центра масс изображения таким образом будет определяться
как:

\begin{equation}
	\begin{aligned}
		C_x&=\frac{M_{10}}{M_{00}}, \\
		C_y&=\frac{M_{01}}{M_{00}},
	\end{aligned}
	\label{centroid-equat}
\end{equation}
где $(C_x, C_y)$ -- координата центра масс изображения.

В библиотеке OpenCV есть функция {\tt moments()}, определяющая
моменты изображения. Добавив в предыдущий код определение
координаты центра масс и построение лучей, получим результат, 
отображённый на рисунке \ref{keypoints-ex}.

\addtwoimghere{pix/defects_and_centroid_example}
{pix/defects_and_centroid_example1}{Результат поиска ключевых точек
руки.}{keypoints-ex}

\subsection{Локализация ключевых точек кисти руки на изображении
на основе непрерывного скелета.}

Для локализации ключевых точек в статье \cite{nosov} предлагается
использовать непрерывный скелет. Предполагается, что уже успешно 
был выполнен этап сегментации и имеется отсегментированное
изображение с силуэтом кисти руки. На основе контурного представления
силуэта жеста строится его скелет. Для определения скелета
используется понятие {\it максимального пустого круга}.

{\bf Определение 1}. Для многоугольной фигуры $F$ {\it максимальным
пустым кругом} называется всякий круг $B$, полностью 
содержащийся внутри фигуры $F$, такой, что любой другой круг $B'$,
содержащийся внутри фигуры $F$, не содержит в себе $B$.

{\bf Определение 2}. {\it Скелетом} многоугольной фигуры $F$
является множество центров её максимальных пустых кругов.

Непрерывный скелет многоугольной фигуры является подмножеством
диаграммы Воронова \cite{mesteckij}. Совокупность общих линий всех пар 
несмежных ячеек диаграммы Воронова образуют ветви скелета 
\cite{mesteckij}. На скелете определена радиальная функция $R(x,y)$,
ставящая в соответствие каждой точке скелета $(x,y)$ значение
радиуса максимального пустого круга с центром в этой точке.

В большинстве случаев скелет ладони имеет шумы в виде
малозначимых ветвей, которые как правило, мешают дальнейшему анализу.
Для удаления шумовых ветвей используется дополнительная обработка,
называемая "стрижкой" \cite{mesteckij}. Процесс "стрижки" заключается
в удалении ветвей, граничащих с контурами силуэта руки.

Существующие эффективные алгоритмы позволяют выполнять построение 
скелета за время $O(N\log{N})$, где $N$ -- число вершин в
многоугольнике \cite{mesteckij-rejer}. В связи с тем, что скорость
построения скелета напрямую зависит от количества углов
многоугольной фигуры, то для ускорения построения скелета можно
применить аппроксимацию этой фигуры \cite{nosov-2}. 

Демонстрация процесс построения скелета представлена на рисунке
\ref{skeleton-ex}. На основе непрерывного скелета и радиальной
функции $R(x,y)$ можно с большой точностью вычислить координаты
кончиков пальцев и координаты центра ладони. Каждый палец может
принимать два условных состояния: сжатый в кулак или разжатый.
Все ветви скелета, соответствующие пальцу, оканчиваются вершиной
степени 1. Ветвь пальца можно разделить на две части: палец и пясть.

\addimghere{pix/skeleton_example}{1}{Процесс построения скелета:
{\it a} -- исходное изображение; {\it б} -- аппроксимированное
изображение; {\it в} -- скелет многоугольника; {\it г} -- 
скелет после стрижки}{skeleton-ex}

Для классификации ветвей пальцев используется набор эвристических 
правил:
\begin{enumerate}
	\item Ветвь пальца лежит на графе между вершинами со степенями
1 и 3.
	\item Радиальная функция ветви на вершине степени 1 увеличивается
более чем в 2,5 раза по сравнению с вершиной степени 3.
	\item Радиальная функция начинает резко расти, то есть частные
производные $R'$ больше заданного порога.
\end{enumerate}

Первая точка на ветви, где производная радиальной функции превышает
заданный порог, является точкой конца пальца. Центром ладони будем
считать точку, лежащую на скелете ладони, радиальная функция
которой принимает максимальное значение. На рисунке 
\ref{skeleton-result-ex} демонстрируется результат вычисления
ключевых точек на изображении.

\addtwoimghere{pix/skeleton_result_1}{pix/skeleton_result_2}
{Определение ключевых точек: {\it а} -- исходное изображение;
{\it б} -- скелет и ключевые точки на нём.}{skeleton-result-ex}

Для распознавания простого, ограниченного набора жестов достаточно
составить набор эвристических правил, основанных на следующих
данных: количество пальцев, их длина, количество циклов в графе и их 
габариты. В более сложных случаях набора эвристических правил мало, и
для распознавания жестов применяются дескрипторы формы кисти руки,
состоящие из определённых инвариантных признаков.

Достоинством метода распознавания жестов на основе непрерывного
скелета является его быстродействие, высокая точность локализации
особых точек и, как следствие, высокий результат распознавания. 
